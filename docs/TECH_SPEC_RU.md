# TECH_SPEC (RU): архитектура и контракты системы

Актуально на: 2026-02-07 13:55 MSK

Документ описывает целевую архитектуру связки Telegram ↔ VPS ↔ Яндекс.Диск и то, что должно быть истинным (инварианты). Подробные правила процесса см. в `docs/WORKFLOW_CONTRACT_RU.md`, продуктовые цели — в `docs/PRD_RU.md`.


## 0) Карта кода (как сейчас)

- Telegram UI (aiogram): `src/adaspeas/bot/main.py`
- Worker (очередь Redis): `src/adaspeas/worker/main.py`
- Yandex Disk client: `src/adaspeas/storage/yandex_disk.py`
- SQLite schema / DB: `src/adaspeas/common/db.py`
- Config: `src/adaspeas/common/settings.py`
- Docker compose: `docker-compose.yml`, `docker-compose.prod.yml`

### Контракт /data (SQLite WAL) и права

- SQLite работает в WAL режиме и при записи создаёт рядом с БД файлы `*.db-wal`/`*.db-shm`.
- bot/worker запускаются не от root (пользователь приложения).
- Инвариант: каталог `/data` (bind-mount или volume) **должен быть writable** для UID/GID приложения.

Гарантия:
- В обоих compose-файлах есть one-shot сервис `init-app-data`, который перед стартом bot/worker делает `mkdir -p /data && chown -R <UID>:<GID> /data`.
- Для аварийного восстановления см. `docs/OPS_RUNBOOK_RU.md` (раздел про "readonly database") и цели `make fix-data-perms*`.

Важно: карта выше отражает текущую раскладку файлов, но не означает, что реализация уже соответствует PRD. Несоответствия фиксируем в ROADMAP и ADR.


## 1) Компоненты и границы

1) **Telegram клиент (пользователь/админ)** — только интерфейс.
2) **Bot service** — обработка команд/кнопок, проверка доступа, чтение каталога из SQLite.
3) **Worker service** — фоновые задачи (доставка файлов, уведомления, синхронизация).
4) **SQLite** — “кэш‑истина” на VPS: каталог, пользователи, аудит.
5) **Redis** — очередь задач.
6) **Yandex Disk API** — внешний источник структуры папок и файлов.
7) **Local Bot API Server (опционально, но фактически обязателен для “библиотеки”)** — локальный прокси Bot API, снимающий лимиты по размеру файлов.

Инвариант: бот не делает сетевые запросы к Яндекс.Диску “в момент клика пользователя” для построения списка. UI читает из SQLite быстро, синхронизация происходит отдельно.


## 2) Telegram: лимиты и следствия

### 2.1) Размеры файлов

- При работе через стандартный Bot API (`https://api.telegram.org`) бот может загружать файлы до **50 MB**, а скачивать файлы с Telegram серверов до **20 MB**.
- При работе через **Local Bot API Server** (режим `--local`) лимит загрузки повышается до **2000 MB**, а скачивание возможно “без лимита” (практически до тех же 2 GB).

Следствие: для проекта “закрытая библиотека” Local Bot API Server рассматривается как обязательный компонент (см. OPS).

### 2.2) Inline‑кнопки и payload

`callback_data` для inline‑кнопок ограничен **1–64 байта**.
Следствие: нельзя класть в callback реальный путь/имя файла. В callback кладём короткое действие + integer id (например `nav:123`, `dl:456`).


## 3) Данные и модель хранения

Цель БД: быть “быстрым кэшем” и источником для UI, а не зеркалом всех метаданных диска.

### 3.1) Таблица каталога (целевая)

`catalog_items` (в текущем коде уже есть, но будет расширена):
- `id` (int)
- `parent_id` (int|null) — дерево папок
- `name` (text)
- `path` (text) — внутренний путь в хранилище (не показывать пользователю)
- `type` (folder|file)
- `size` (int|null)
- `sha256` (text|null) — опционально
- `modified_at` (datetime|null)
- `mime_type` (text|null)
- `tg_file_id` (text|null) — кэш Telegram file_id для повторной отправки
- `tg_file_unique_id` (text|null) — для устойчивой идентификации, но не для отправки
- `updated_at` (datetime)

### 3.2) Пользователи (целевая)

`users`:
- `tg_user_id` (int, PK)
- `status` (guest|pending|active|expired|blocked)
- `access_expires_at` (datetime|null)
- `user_note` (text|null) — то, что заполняет пользователь для идентификации
- `admin_note` (text|null) — заметка админа
- `created_at`, `updated_at`

### 3.3) Аудит

`audit_downloads`:
- `id`
- `ts` (datetime)
- `tg_user_id`
- `catalog_item_id`
- `result` (ok|error)
- `error` (text|null)


## 4) Синхронизация каталога (Disk → SQLite)

Требования:
- синхронизация запускается по расписанию (например, раз в 10 минут) и/или вручную админом;
- бот UI читает только из SQLite;
- синхронизация должна корректно обрабатывать большие папки (пагинация по `limit/offset`), иначе каталог будет “обрезан”.

Алгоритм (цель):
1) Берём корневой путь каталога (например `Zkvpr`).
2) Рекурсивно обходим папки, запрашивая содержимое порциями (`limit`, `offset`) до исчерпания.
3) Апсертим элементы в `catalog_items`:
   - папки: создаём/обновляем, ставим `parent_id`.
   - файлы: создаём/обновляем метаданные.
4) Удалённые на диске элементы помечаем как удалённые или удаляем из БД (выбор зависит от политики аудита; минимально — удалять, чтобы не показывать “призраков”).
5) Пишем `last_catalog_sync_at` (можно в отдельной таблице `meta`).

Инварианты:
- синхронизация не блокирует обработку сообщений бота;
- синхронизация должна быть идемпотентна;
- UI всегда может показать “данные устарели, последнее обновление …”.


## 5) Навигация в Telegram (Inline Catalog)

UI строится как дерево:
- “текущая папка” → список папок + список файлов;
- кнопка “Назад”;
- (опционально) кнопка “Обновить каталог” только админам.

Технически:
- callback: `nav:<folder_id>` — открыть папку,
- callback: `dl:<file_id>` — запросить скачивание,
- callback: `back:<folder_id>` или стек в state (лучше: передавать parent_id).

Инвариант: один экран = одно сообщение, которое редактируется, а не “спамится” в чат.


## 6) Доставка файлов (Disk → VPS → Telegram)

Поток:
1) Пользователь нажимает файл.
2) Bot проверяет доступ и ставит задачу в очередь.
3) Worker обрабатывает задачу:
   - если у файла есть `tg_file_id`: отправляет по `file_id` (быстро, без скачивания с Диска);
   - иначе скачивает файл с Диска во временную директорию и отправляет как новый upload;
   - после успешной отправки сохраняет `tg_file_id`/`tg_file_unique_id` в БД.
4) Пишем запись в `audit_downloads`.

Нюансы:
- При Local Bot API Server можно отправлять файлы локальным путём (`file://...`) без multipart‑upload.
- Если файл слишком большой для текущего режима, задача должна завершаться “внятной” ошибкой в аудит и сообщением админу.


## 7) Уведомления и антифлуд

Уведомления о сроках доступа делаются из worker по расписанию.

Правила:
- предупреждение пользователю и админу за 24 часа до истечения;
- отправка с ограничением скорости (чтобы не получать 429) и с ретраями.


## 8) Конфигурация (env)

Каноничный список переменных см. `.env.example`.

Минимум для запуска (dev/CI):
- `BOT_TOKEN`
- `ADMIN_USER_IDS` (опционально, CSV)
- `STORAGE_MODE` (`yandex` | `local`)
- `SQLITE_PATH`
- `REDIS_URL`

Если `STORAGE_MODE=yandex`:
- `YANDEX_OAUTH_TOKEN`
- `YANDEX_BASE_PATH` (например `/Zkvpr`)

Если `STORAGE_MODE=local`:
- `LOCAL_STORAGE_ROOT`

Local Bot API Server (опционально, но нужен для файлов > 50 MB):
- `USE_LOCAL_BOT_API=1`
- `LOCAL_BOT_API_BASE` (по умолчанию `http://local-bot-api:8081`)
- `TELEGRAM_API_ID`, `TELEGRAM_API_HASH` (нужны для запуска сервиса `local-bot-api`)

Prod (Caddy/HTTPS/метрики):
- `ACME_EMAIL`, `METRICS_USER`, `METRICS_PASS`, `IMAGE`


## 9) Известные разрывы (gap) относительно текущего кода

- `/categories` пока делает синхронное чтение хранилища и печатает текстовый список (без inline‑навигации и без редактирования одного сообщения).
- Нет фоновой периодической синхронизации каталога по расписанию (SQLite как кэш есть, но обновляется “по запросу”).
- Нет модели доступа пользователей (status/expiry) и админ‑инструментов управления доступом.
- Нет админ‑уведомлений об ошибках/истечениях (как минимум: отправка всем `ADMIN_USER_IDS`).
- Нет аудита скачиваний и админ‑статистики.

Закрытие этих разрывов и порядок — в `docs/ROADMAP_RU.md` и ADR.

## История изменений
| Дата/время (MSK) | Автор | Тип | Кратко | Commit/PR |
|---|---|---|---|---|
| 2026-02-06 00:10 MSK | ChatGPT | doc | Зафиксирована базовая архитектура и лимиты Telegram для “библиотеки” | |
| 2026-02-06 12:45 MSK | ChatGPT | doc | Синхронизированы названия env/компонентов с кодом и уточнены текущие gap | |
